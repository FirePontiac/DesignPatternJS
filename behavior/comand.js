// Позволяет создавать определённую абстрактную оболочку над функционалом, который позволяет управлять
// но уже через другой обьект , тем самым записывая определённые состояния которые бытли вызваны
// redux !
class MyMath {
    constructor (initialValue = 0) {
        this.num = initialValue
    } // Далее создадим 2 метода
    square() {
        return this.num ** 2
    }
    cube() {
        return this.num ** 3
    }

}
// Применим comand Паттерн
class Command {
    constructor(subject) { // Тут в скобках что над чем формируем данную абстрактную оболочку
        this.subject = subject // Занесли, чтобы сохранить в текущем контексте
        this.commandsExecuted = [] // в этом массиве будем хранить список команд которые когда либо были вызваны
    }
    execute(command) { // в этом методе в строковом формате будем принимать значение
        this.commandsExecuted.push(command) // в массив добавляем информацию о том какая команда была вызвана
        return this.subject[command] () // Что получить результат, по ключу command и тут же ее вызываем ()

    }
}

const x = new Command(new MyMath(2))
console.log(x.execute('square'))
console.log(x.execute('cube'))
console.log(x.commandsExecuted) // Получаем массив команд которые были вызваны, некий дополнительный обьект
// У этого обьекта мы можем вызывать определённый набор методов, 
// Этот обьект также тригерит нужный нам класс и при этом хранит метаинформацию 